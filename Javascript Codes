1. Object Inversion
Question: Invert the key-value pairs of an object. If a value is a duplicate, the final key should be an array of the original keys.

Input: {'a': 1, 'b': 2, 'c': 1}
Expected Output: { '1': ['a', 'c'], '2': 'b' }

let input = {'a': 1, 'b': 2, 'c': 1, 'd' : 2}
// let output =   { '1': ['a', 'c'], '2': 'b' }

function invert(input){
  let result = {}
    const keys = Object.keys(input)
   
for(let i in keys){
    let key = keys[i]
    const resultkey = result[input[key]]
   if(resultkey){
      result[input[key]] = [result[input[key]], key]
   }else{
      result[input[key]] = key
   }

}

    return result
}

console.log(invert(input))

---------------------------------------------------

2. Deep Merging
Question: Implement a function to deeply merge two or more objects. The function should handle nested objects and arrays without overwriting existing data.

let obj1 = { a: 1, b: { c: 2 } }
let obj2 = { b: { d: 3, f: 5}, e: 2 }
let obj3  = {l: 4, o: {s: 4}, b: {k: 4} }
// Expected Output: { a: 1, b: { c: 2, d: 3 }, e: 4 }

// Generic method for more than two objects
function merge(...entries){
let result = {}
    for(let current of entries){
            for(let i in current){
                if(result[i]){
                    result[i] = Object.assign(result[i], current[i])
                }else{
                    result[i] = current[i]
                }
            }
    }
    return result
}

//for two objects
function merge(obj1, obj2){
    let result = {}
    for(let i in obj1){
        if(result[i]){
            
        }else{
            result[i] = obj1[i]
        }
    }
     for(let i in obj2){
        if(result[i]){
            result[i] = Object.assign(result[i], obj2[i])
        }else{
            result[i] = obj2[i]
        }
    }
    return result
    
}
console.log('result', merge(obj1, obj2))
-------------------------------------------------------------------------
3. Object Key Reformatting
Question: Write a function to convert an object's keys from camelCase to snake_case.

let input = { firstName: 'John', lastName: 'Doe' }
// Expected Output: { first_name: 'John', last_name: 'Doe' }

function changeCasing(input){
    // method 1
    let result= {}
    for(let i in input){
        let name = i.toLowerCase().split('n')
        let finalName = name[0]+'_n'+name[1]
        console.log(finalName)
        result[finalName] = input[i] 
    }
    return result
    
    // method 2
    let result = Object.keys(input).reduce((acc, cur)=>{
        let finalName = cur.toLowerCase().split('n').join('_n')
        return acc[finalName] = input[cur], acc
    },{})
    return result
  
}
console.log(changeCasing(input))

------------------------------------------------------

4. Grouping by Multiple Keys
Question: Group an array of objects by the values of multiple specified keys.

const input =  [{ type: 'fruit', color: 'red' }, { type: 'fruit', color: 'green' }, { type: 'vegetable', color: 'red' }]
// Expected Output: { 'fruit-red': [{...}], 'fruit-green': [{...}], 'vegetable-red': [{...}] }

const merge =(input)=>{
    
    // method 1
    let result = {}
  for(let i of input){
      const {type, color} = i
     const key =`${type}-${color}`
     if(!result[key]){
         result[key] = []
     }
     result[key].push(i)
    
  }

// method 2 using reduce
return input.reduce((acc,cur)=>{
    const {type,color} = cur
    const key = `${type}-${color}`
    if(!acc[key]){
        acc[key] = []
    }
    acc[key].push(cur)
    return acc
}, {})

}
console.log(merge(input))
------------------------------------------------------

6. Value-Based Filtering
Question: Filter an array of objects to return only those objects where at least one of their properties has a truthy value.
let input =  [{ id: 1, name: 'A' }, { id: 2, name: null }, { id: 3, name: '' }]

// Expected Output: [{ id: 1, name: 'A' }]

function filterNull (input){
    return input.filter((inp)=> inp.name)
}
console.log(filterNull(input))

----------------------------------------------------
7. Object Key Sorting
Question: Return a new object with its keys sorted alphabetically.
For sorting arrays use this method

let input =  { b: 2, a: 1, c: 3 }

// Expected Output: { a: 1, b: 2, c: 3 }

function sorted(input){
    let result = {}
    let sorted = Object.keys(input).sort((a,b)=> input[a] - input[b])
    for(let i of sorted){
        result[i]= input[i]
    }
    return result
}
console.log(sorted(input))
----------------------------------------------------------
9. Dynamic Sorting
Question: Create a function that sorts an array of objects by a dynamic key and sort order (ascending or descending).
For sorting objects use this method

let input =  [{ name: 'A', age: 30 }, { name: 'B', age: 25 }], key = 'age', order = 'desc'
// Expected Output: [{ name: 'A', age: 30 }, { name: 'B', age: 25 }]

function sorting(input, key, order){
  let sorted = input.sort((a,b)=> {
    if (a[key] < b[key]) return order === 'asc' ? -1 : 1;
    if (a[key] > b[key]) return order === 'asc' ? 1 : -1;
  })
  return sorted
}
console.log(sorting(input,'age', 'asc', ))

-----------------------------------------------------

11. Array to Nested Object with Aggregation
Question: Transform a flat array of transaction objects into a nested object, grouped by year, month, and then by transaction type, with the total amount for each type.
let input = [
  { date: "2023-01-01", type: "food", amount: 10 },
  { date: "2023-01-05", type: "travel", amount: 50 },
  { date: "2023-02-10", type: "food", amount: 20 },
];

// Expected Output: { '2023': { '01': { 'food': 10, 'travel': 50 }, '02': { 'food': 20 } } }

function transaction(input) {
  let result = {};
  for (let i of input) {
    const { date, type, amount } = i;
    const [year, month] = date.toString().split("-");
    if (!result[year]) {
      result[year] = {};
    }
    if (!result[year][month]) {
      result[year][month] = {};
    }
    if (!result[year][month][type]) {
      result[year][month][type] = 0;
    }
    result[year][month][type] += amount;
  }

  return result;
}
console.log(transaction(input));

--------------------------------------------------------------

let input = [{ name: 'A', email: 'a@b.com' }, { name: 'B', phone: '123' }], key = 'email'
// Expected Output: [{ name: 'A', email: 'a@b.com' }]

function takeKey (input, key){
    return input.filter((inp)=> inp[key])
}
// console.log(takeKey(input, 'email'))

---------------------------------------------------------
let inp =  [{ age: 10 }, { age: 25 }, { age: 40 }]
let test = (obj) => obj.age >= 18

// Expected Output: [[{ age: 25 }, { age: 40 }], [{ age: 10 }]]

// function condition(cond){
//     return 
// }
function fetchOutput(inp, cond){
  let pass = []
  let fail = []
  for(let i of inp){
      if(test(i)){
          pass.push(i)
      }else{
          fail.push(i)
      }
  }
  return{ pass, fail}
}
// console.log(fetchOutput(inp, test))

-----------------------------------------------------------------

let obj = { a: 1, b: 2 }
// Expected Output: [{ key: 'a', value: 1 }, { key: 'b', value: 2 }]

function addKeys(obj){
    let entry = Object.entries(obj)

    let result = entry.reduce((acc,cur)=>{
        let per = {}
       let [key,value] = cur
       // if using per
    //   per['key'] = key
    //   per['value'] = value
        acc.push({key, value})
        return acc
    }, [])
    return result
}

// console.log(addKeys(obj))
-----------------------------------------------------------------------
const fruitsArray = [
  { category: "fruit", subcategory: "citrus", name: "lemon" },
  { category: "fruit", subcategory: "citrus", name: "orange" },
  { category: "fruit", subcategory: "sweet", name: "lichi" },
];

// Expected Output: { 'fruit': { 'citrus': [{...}, {...}] } }

function nestedFruits(fruits){
    let result = {}
    for(let fruit of fruits){
        const {category, subcategory, name} = fruit
        if(!result[category]){
            result[category] = {}
        }
        if(!result[category][subcategory]){
            result[category][subcategory] = []
        }
        result[category][subcategory].push(fruit)

    }
    return result
}
// console.log(nestedFruits(fruitsArray))
--------------------------------------------------------------------------
let arr = [{ a: 1, b: 2 }, { a: 1, c: 3 }], subset = { a: 1, b:2 }
// Expected Output: [{ a: 1, b: 2 }, { a: 1, c: 3 }]

function filterAnd(arr, subset){
    // 1st process
    let keys = Object.entries(subset)
    console.log(keys[0])
    let key = keys[0][0]
    let value = keys[0][1]
    let result = arr.filter((ar)=> ar[key] === value
    )
return result
}
//2nd process/ generic process.
function filterAnd(arr, subset) {
  const entries = Object.entries(subset);
  return arr.filter(obj =>
    entries.every(([key, value]) => obj[key] === value)
  );
}

// console.log(filterAnd(arr, subset))
-----------------------------------------------------------------------
let arr1 = [{ status: 'a', value: 10 }, { status: 'a', value: 20 }, { status: 'b', value: 30 }] 
let groupBy = 'status'
let aggregateBy = 'value' 
let type = 'sum'

// Expected Output: { 'a': 30, 'b': 30 }

function aggregate(arr1, groupby, aggregateBy, type){
    let result = {}
    for(let i of arr1){
        const {status, value} = i
       console.log(i,status, value)
        if(!result[status]){
            result[status] = value
        }else{
            console.log(value)
            if(type=== 'sum'){
                result[status] = value + result[status]
            }
            if(type === 'substact'){
                result[status] = result[status]- value
            }
        }
    }
    return result
}

console.log(aggregate(arr1, 'status', 'value', 'substract'))






