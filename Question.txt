https://plainenglish.io/blog/50-javascript-output-questions
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Question: What is typeof []
// Answer: Object. Actually Array is derived from Object. If you want to check array use Array.isArray(arr)
-----------------------------------------------------
 Why does console.log(~8) output -9?
~ is a bitwise operator that flips bits in the bit representation of a number. In JavaScript all bitwise operations are performed on 32-bit binary numbers.8 is represented as 00000000000000000000000000001000. The ~ operator flips this to 11111111111111111111111111110111, which is -9.
-------------------------------------------------
console.log(isNaN(false));
This will output false. The value false will be coerced to 0, and NaN(0) will return false.
---------------------------------------------------------------
//
console.log(new Number(5) === 5);    //false because new Number(5) is an object and 5 is number
-------------------------------------------   
const myArray = ['thing 1', 'thing 2', 'thing 3'];
myArray.thing4 = 'not a thing';
console.log(myArray)  // [0: 'thing 1', 1: 'thing 2', 2: 'thing 3', thing4: 'not a thing'] 

for(const element in myArray){
  console.log(myArray[element]);   // thing 1 thing 2 thing 3 not a thing  // unexpected
}
---------------------------------------------------------
What will the code below output to the console and why?

for(let i = 0; i < 10; i++){
  if(i === 3){
   return;
  }
  console.log(i);
}
This will throw a syntax error. The return statement is not a valid way of ending a for block. If you want to end a loop, use break.
--------------------------------------------------------------
Objects only support for in loop method not for of...

//Question : 
const length = 4;
const numbers = [];
for (var i = 0; i < length; i++);{
  numbers.push(i + 1);
}

Let's take a closer look at the semicolon ; that appears right before the opening curly brace {:
Being easily overlooked, this semicolon creates a null statement. The null statement is an empty statement that does nothing.

The above code is equivalent to the following:
const length = 4;
const numbers = [];
var i;
for (i = 0; i < length; i++) {
  // does nothing
}
{ 
  // a simple block
  numbers.push(i + 1);
}
numbers; // => ---> --->  [5]

for() increments i variable until 4. Then JavaScript enters one time the block { numbers.push(i + 1); }, pushing 4 + 1 to numbers array.
Thus numbers is [5].
--------------------------------------------------------------
//Question: 
function arrayFromValue(item) {
  return
    [item];
}

arrayFromValue(10)   // ?? 

it's easy to miss the new line between the return keyword and [item] expression.
However, this newline makes the JavaScript automatically insert a semicolon between return and [item] expression.
Here's an equivalent code with the semicolon inserted after return:

function arrayFromValue(item) {
  return;
  [item];
}

arrayFromValue(10); // => undefined
return;              // inside the function makes it return undefined.
--------------------------------------------------------------------------
//Question: 
const myName = 'Jim'; // Line 1

if(myName){ // Line 2
  myName = 'Joe'; // Line 3
  let myName = 'Jeff'; // Line 4    // throws error, cannot access myName before initialization because 					of TDZ of myName, ignore 
}
myName with const..

same question, removed line 4......
const myName = 'Jim'; // Line 1

if(myName){ // Line 2
  myName = 'Joe'; // Line 3       // cannot change variable myName defined with const..
}
-------------------------------------------------------------------------------
// Question: What is typeof arguments
// Answer: Object. arguments are array like but not array. it has length, can access by index but can't push pop, etc.

// Question: What is the value of typeof null
// Answer: "object"

// Prototype chaining: 
let arr = ['sagar', 'badal']
now, 
arr.__proto__  // returns constructor function which contains all array properties.
arr.__proto__.forEach // will return the function itself as it is contained in construtor which is called from arr.__proto__
arr.__proto__.__proto__ // it returns Object.Prototype's constructor since Array is defined from Object, hence calling array's parent will give Object.prototype' constructor.
arr.__proto__.__proto__.__proto // the parent of object or the top most is null. 


var hero = {
  _name: "XYZ",
  getSecretIdentity: function () {
    return this. Name;
  },
};

var stoleSecretIdentity = hero. GetSecretIdentity;

console.log (stoleSecretIdentity ()); // undefined
console.log (hero. GetSecretIdentity()); //xyz

//Explanation:
When you run this code, the first console.log (stoleSecretIdentity ()) will return undefined because when you assign the getSecretIdentity function to the stoleSecretIdentity variable, you lose the context of the hero object. This keyword inside the function will now refer to the global object, and there is no _name property on the global object, so the getSecretIdentity function returns undefined.
The second console.log (hero. GetSecretIdentity ()) will return 'XYZ' because the context of the hero object is preserved and the this. Name returns the value of 'XYZ'
It's important to note that, when you assign a method to a variable and call it, the context of the function is lost, and this keyword will refer to the global object (or undefined in strict mode). To preserve the context of the function, you can use the bind method to create a new function with a fixed context.

To resolve this, we can code
var hero = {
    _name: 'XYZ',
    getSecretIdentity: function (){
        return this. Name;
    }
};

var stoleSecretIdentity = hero. getSecretIdentity. bind(hero); <-- binding
 console.log (stoleSecretIdentity ());
console.log (hero. GetSecretIdentity ());


The bind method creates a new function with this keyword set to the first argument passed to the method, which in this case is the hero object. Now when you call stoleSecretIdentity () it will return 'XYZ' as the context of the hero object is preserved and the this. Name returns the value of 'XYZ'
It's important to note that bind method creates a new function and does not change the original function so the original function can still be called normally.

//  var x = 23;
      (function(){
        var x = 43;
        (function random(){
          x++;  // if X++ not there ,then console.log(x) will be undefined.
          res.send(x)    //NaN because of X++ ,  --> undefined++  --> NaN
          var x = 21;
        })();
      })();

//function foo() {
          let a = b = 0;
          a++;
          return a;
        }
        foo();
        typeof a; // => undefined
        typeof b; // => number

-------------------------------------------------------------
const person1 = {
  name: 'Willie',
  address: {
    city: 'Austin',
    state: 'Texas'
  }
};

const person2 = {...person1};

person2.name = 'Waylon';
person2.address.city = 'Fort Worth';

console.log(person1.name); // Willie
console.log(person1.address.city)  // Fort Worth 

// The change is due to the fact that object created with spread operator and Object.assign({}) creates a shallow copy for one level objects but deep copy for nested objects.
person1 and person2 are not the same object, but both person1.address and person2.address are pointed to the same object in memory. 
-------------------------------------------------------------------------

const memoryFunction = (x) => {
  const y = x;
  return (z) => {
    console.log(y * z);
  }
}

const innerMemoryFunction = memoryFunction(5);

memoryFunction(6)(6); // Line 8     // 36
innerMemoryFunction(6)(6); // Line 9    //  Shows 30 but then due to extra (6) arguement throws an 						error. 
---------------------------------------------------------------

//for (var i = 0; i < 3; i++) {
  const log = () => {
    console.log(i); // 3 3 3 three times program will execute.
  };
  setTimeout(log, 100);
}
//Explanation: In this code, we have a for loop that runs 3 times and each time it creates an anonymous function log that uses the console.log(i) statement to log the current value of i at the time of the function call.
It also sets a timeout of 100 milliseconds before calling the log function using setTimeout(log, 100).
When the for loop completes the execution, all three log functions will have been created with the same i value, which will be 3, therefore all three function calls will log 3 to the console.
This is an example of closure, where the log function has access to the variable i in the parent scope, even though the for loop has completed execution.
It's important to note that if we use let instead of const in the for loop, the output will be 0,1,2 as it creates a new binding for each iteration of the loop, and the log function will have access to the current value of i at the time of the function call.

//for (let i = 0; i < 3; i++) {
  const log = () => {
    console.log(i); // 0,1,2 three times program will execute.
  };
  setTimeout(log, 100);
}
//Explaination: In this code, the for loop creates a new binding for the variable i for each iteration, so when the log function is called, it has access to the current value of i at the time of the function call. Since we are using let instead of const in the for loop, the output will be 0,1,2 as the variable i is scoped inside the for loop( or we can say let is block scoped hence the value keeps on reinitializing)  block and the log function will log the current value of i at the time of the function call.
The setTimeout function is a non-blocking function, it will execute the log function after 100 milliseconds, and since i is scoped inside the for loop, it will not change the value of i when the log function is called.
It's important to note that when using let, the variable is scoped within the block, so the i variable is created and destroyed for each iteration, allowing the log function to access the correct value of i at the time of the function call. Hence 0 1 2 
When there is var, the variable is function scoped and the “i” keeps the reference to the current value of the iteration every time it goes on increasing and since it has a value of 3 at the time of the end of loop, and because of set time. When set time out ends it will print the latest value it is referencing to which is 3. Hence 3 3 3.

Solving this by using closures:
function a () {
  for (var i =0; i<3; i++) {
     (Function(i) {
      setTimeout (() => {
        console.log(i)
      })
    }) (i)
  }
}
a()
// Explaination: Here, we wrap the call to setTimeout in an anonymous function that takes the current value of i as an argument. This creates a new scope for each iteration of the loop and assigns the current value of i to the parameter of this function. This way, when the setTimeout callback is invoked, it has access to the correct value of i and logs the expected output.
This is the common way to solve this problem, also named as "IIFE" (Immediately Invoked Function Expression) which creates a new scope for each iteration and assigns the current value of the variable to the parameter of this function.

//var obj = {
	  name: "sagar",
  display() {
	    console.log(this.name);
	  },
	Tiger:()=> {
	    console.log(this.name)
	};
	var obj1 = { name: "akash" };
	obj.display.call(obj1);               // akash
	obj.Tiger.call(obj1)              
}

// undefined. Because it is an arrow function which only points to its lexical environment which is the environment for obj which is global scope or window object. And there is no name variable in window,hence undefined.


// var length = 10
  function fn(){
  console.log(this)          // this points to window
  console.log(this.length)  //this.length will shows window's value
}
var obj = {
  length: 5,               //local scope
  method: function(fn){  
      fn()                 // fn will call normally
      arguments[0]()      // arguments will find values from (fn,1), arguments[0] means fn.
}
}
obj.method(fn,1) // fn will call, with 10 value because of outer scope.

//  window, 10 
//  argumentsObj, 2

const a = {};
const b = { key: "b" };
const c = { key: "c" };

a[b] = 123;
a[c] = 456;
Solution
------------
a[b] == a[“[object object]”] == a[c]
Hence,

console.log(a[b]) // 456
console.log(a[c]) // 456

This code creates three empty objects, a, b, and c.
It then adds two properties to a object, where the key of the first property is the object b and its value is 123, and the key of the second property is the object c and its value is 456.
When you try to access the properties of an object using the b and c objects as keys you will get undefined because objects are converted to string representation "[object Object]" when used as object property keys.
So, a[b] and a[c] will be equivalent to a ["[object Object]"] and the value of that property will be 456 which is the last assignment made.
it's not a good practice to use objects as keys in JavaScript because objects are not guaranteed to have a consistent string representation, and so using them as keys can lead to unexpected behavior.

//0.1 + 0.3 = 0.30000000000004
Numbers in JavaScript are treated with floating point precision, and as such they might not give expected results.

Remember promises have higher priority then set timeout, if you get any question where the time setTimeout Is same but promises and setTimeout then output from promise will come earlier

//Question: 
How would you check if a number is an integer?
function isInt(num) {
  return num % 1 === 0;
}

A very simply way to check if a number is a decimal or integer is to see if there is a remainder left when you divide by 1. if remainder is 0 then output is integer.

console.log(isInt(4)); // true
console.log(isInt(12.2)); // false
console.log(isInt(0.3)); // false

// Question: What is console.log(true+false)
// Answer: 1 here true -->> 1 & false -->> 0 then 1 + 0 -->> 1

// Question: What is 2+true
// Answer: 3. The plus operator between a number and a boolean or two boolean will convert boolean to number. Hence, true converts to 1 and you get result of 2+1

// Question: What is "2"+true
// Answer: 2true here string concatination happer "2"+"true" -->> 2true

// Question: What is the value of -'34'+10
// Answer: -24. minus(-) in front of a string is an unary operator that will convert the string to a number and will make it negative. Hence, -'34' becomes, -34 and then plus (+) will perform simple addition as both the operands are number.

// Question: What is the value of +'dude'
// Answer: NaN. The plus (+) operator in front of a string is an unary operator that will try to convert the string to number. Here, JavaScript will fail to convert the "dude" to a number and will produce NaN.

// Question: If you have var y = 1, x = y = typeof x; What is the value of x?
// Answer: "undefined"

// Question: for var a = (2, 3, 5); what is the value of a?
// Answer: 5. The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand. ref: MDN

// Question: for var a = (1, 5 - 1) * 2 what is the value of a?
// Answer: 8
------------------------------------------------------------------
//working with Reduce functions:
//Return unique types from food array using sets and reduce: 

let food = [
  { name: "chiku", type: "fruit" },
  { name: "apple", type: "fruit" },
  { name: "burger", type: "fast food" },
  { name: "banana", type: "fruit" },
  { name: "tomato", type: "vegetable" },
  { name: "biryani", type: "curry food" },
  { name: "pakoda", type: "appetisers" }
];
let set = food.reduce((a,c)=>{
return a.add(c.type)
},new Set())
let setArray = Array.from(set)        // ["fruit", "fast food", "vegetable", "curry food", "appetisers"]
--------------------------------------------------------------------------
// Function to calculate characters in string…
let str = "hjvuwefgweufgeoeuwgfuegcveuiuducucbwcsaqwuwduoqwofcwebsigcewefbcwefcbiweelcbwvqiawldijwqknqwdklwwofdewbckewbiuubflce"

function countString(str){
    let arr = {}
    for(let i in str){   //0,1,2,3,4………..
        const char = str[i]
        arr[char] = arr[char] + 1 || 1
    }
    console.log(str)
    console.log(arr)
console.log (Object.keys(arr).find((at)=>arr[at]===1)) // to check for non-repeting entries
let keys = Object.keys(arr)
let allSingleString = []
keys.map((key)=> {   if(arr[key]===1){ allSingleString.push(key)}
return allSingleString  returns all element having count 1.
})
}
countString(str)

//Second method uisng reduce: 
  let strCount = str.split('').reduce((a, c) => (a[c] = (a[c] || 0) + 1, a),{}); 
-----------------------------------------------------------------------------
// Implement a function to find the key associated with the highest value in an object containing numerical values using reduce function
function findKeyWithHighestValue(object) {
  const keys = Object.keys(object);
  if (keys.length === 0) {
    return null;
  }
  return keys.reduce((maxKey, currentKey) => {
    return object[currentKey] > object[maxKey] ? currentKey : maxKey;
  });
}
findKeyWithHighestValue({a:1,b:45,c:13,d:23})  // b
---------------------------------------------------------------------------
Write code to capitalize each word after every sentence with reduce: 
let str = "the.garden.is.pink";
console.log(str.split("."));
let palin = str.split(".").reduce((a, c) => {
  let d = c.substring(1);
  let t = c[0].toUpperCase();
  let word = t + d;
  return a +" "+word;
}, "");                    
------------------------------------------------------------------------------
// writing function to check if two objs are same ? json.stringify
And to check if the keys are same irrespective of the values second part

let obj1 = { name: "sagar", age: 23 };
let obj2 = { name: "sagar", age: 23};

//first part
if(JSON.stringify(obj1) === JSON.stringify(obj2)){
  console.log('same from stringy')     // same from stringy
}else{
  console.log('not same from stringy')
}
//second part
function compare(obj1, obj2) {
  if(Object.keys(obj1).length !== Object.keys(obj2).length){     // for comparing the length of the object keys, if keys mismatch then automatically, values won't be same
      return 'not same'
  }
  let tag = true;
  for (let i in obj1) {
    if (obj2.hasOwnProperty(i)) {
      tag = true;
    } else {
      tag = false;
      return 'not same'
    }
  }
  return "same";
}
let c = compare(obj1, obj2);    //same
-----------------------------------------------------------------------

// function involving strings: 
function findSubString(str) {
  //if substring
  let substring = "ou";
  let result = str.includes(substring);

  //where substring returns first index
  result = str.indexOf(substring);

  // how many times substring present
  result = str.split(substring).length - 1;

  //return all the strings containing substring and find indexes of the substring
  str = str.split(" ");
  let indexArray = [];
  result = str.filter((ar, index) => {
    if (ar.includes(substring)) {
      indexArray.push(index);
      return ar.includes(substring)
    }
  });
  return result;
}
let str = "hello by godou who areou you, i dont knou you againou";
const c = findSubString(str);
console.log(c);
-----------------------------------------------------------------------
//  how many methods to write Function to reverse a String: 
1.	Using Foor loop (avoid)
2.	Using split (), reverse (), join ()
3.	Using split (), and reduce <- use this
4.	Use […str]. Reduce ((x,y)=> y.concat(x))
5.	Use recursion by return ReverseString (str.substr(1) + str.charAt(0) )  <-- pushing each character at the back
---------------------------------------------------------------------------
// Generate OTP of 4 letters:
function generate(){
    const otp = Math.floor(Math.random()*9000+1000)
    console.log(otp)
}
generate()
----------------------------------------------------------------------------
const input = [2, 7, 11, 4, -2];

// find the sum of all the array elemetns except same index
function addExceptIndex(input) {
  return input.map((input1, index) => {
    let inputCopy = input.slice();
    inputCopy.splice(index, 1);
    return inputCopy.reduce((a, c) => {
      return a + c;
    }, 0);
  });
}
let c = addExceptIndex(input);
console.log("c", c); // [20, 15, 11, 18, 24]
---------------------------------------------------------------------------------
let input1 = { a: 1, b: 2, c: 3, d: 10, e: 12 ,p:12};
const input2 = { a: 2, e: 12, f: 6, d: 10 , p:12, i:2};

function findCommonKeyValuePairs(input1, input2) {
  let obj = {};
  for (let i in input1) {
    if (input2.hasOwnProperty(i)) {
      if (input1[i] === input2[i]) {
        obj[i] = input1[i];
      }
    }
  }
  return obj;
}
let c = findCommonKeyValuePairs(input1, input2);
console.log(c);

//output : {d:10, e:12}

Alternate to this: 
----------------------------------------------------------------
function findCommonKeyValuePairs(obj1, obj2) {
  const entries1 = Object.entries(obj1);
  const entries2 = Object.entries(obj2);
  const commonEntries = entries1.filter(([key, value]) => obj2[key] === value);
  return Object.fromEntries(commonEntries);
}

const input1 = { a: 1, b: 2, c: 3, d: 10, e: 12, p: 12 };
const input2 = { a: 2, e: 12, f: 6, d: 10, p: 12, i: 2 };

const output = findCommonKeyValuePairs(input1, input2);
console.log(output);
---------------------------------------------------------------------

//find the first missing odd number for any multiplier/
function missingOdd(arr) {
  let result = 0;
  let n = 3;
  let current = arr[0];

  for (let i = 0; i <= arr.length; i++) {
    if (arr[i] !== current) {
      result = current;
      break;
    }
    current = current + n;
  }
  return result;
}
let arr = [3, 6, 5, 7, 9, 11, 15, 17, 19];
let a = missingOdd(arr);
console.log(a);

---------------------------------------------------------------------
//function to check if the strings are anagram of each other
function anagrams(str1,str2){
    str1 = str1.toLowerCase().split('').sort().join('')
    str2 = str2.toLowerCase().split('').sort().join('')
    return str1 === str2
    
}
let str1 = "hello"
let str2 = "olleh"
console.log(anagrams(str1,str2))  //true

---------------------------------------------------------------------------
// Reverse a code word by word

function reverse(str) {
  let result = str.split(" ").map((a) => {
    return a.split("").reduce((a, c) => c + a, "");
  });
  return result.join(' ');
}
let str = "This is JavaScript code";
let c = reverse(str);
console.log(c);  // sihT si tpircSavaJ edoc 
-------------------------------------------------------------------
// How would you use a closure to create a private counter?
function counter() {
  var _counter = 0;
  // return an object with several functions that allow you
  // to modify the private _counter variable
  return {
    add: function(increment) { _counter += increment; },
    retrieve: function() { return 'The counter is currently at: ' + _counter; }
  }
}

// error if we try to access the private variable like below
// _counter;

// usage of our counter function
var c = counter();
c.add(5); 
c.add(9); 

// now we can access the private variable in the following way
c.retrieve(); // => The counter is currently at: 14
--------------------------------------------------------------------------
// function to count vowels in a String

function CountVowels(str){
    let vowels = ['a','e','i','o','u']
    let obj = {}
    str = str.toLowerCase()
    let count = 0
    for(let i =0; i<str.length; i++){
        var char = str[i]
        if(vowels.includes(char)){
            obj[char] = (obj[char] || 0) + 1 
	    count++
        }
    }
	obj = Object.keys(obj) // [e,o,i,a] // gives unique values
    return {obj,count}
}
let str = 'hello India'
console.log(CountVowels(str))   // { obj: { e: 1, o: 1, i: 2, a: 1 }, count: 5 }
-------------------------------------------------------------
// Question: What is the value of !'bang'
// Answer: false. ! is NOT.

//Question: What is the output?
	var y = 1; 
	if (function f() {}) {
	  y += typeof f;
	}
	console.log(y);  //1undefined

	var k = 1;
	if (1) {
	  eval(function foo() {}); 
	  k += typeof foo;
	}
	console.log(k);  // 1undefined
	
	var k = 1;
	if (1) {
	  function foo() {};  // 
	  k += typeof foo;
	}
	console.log(k); // output 1function


 //<-- evaluating foo to true inside if, hence typeof foo = undefined, //<-- evaluating foo hence typeof foo = undefined , <--directly checking typeof foo, hence function...

//any function without return statement returns undefined. 
// If condition statement evaluate using eval so eval(function f() {}) which return function f() {} which is true so inside if statement code execute. typeof f return undefined because if statement code execute at run time, so statement inside if condition evaluated at run time.

// Question: What is the value of parseFloat('12.3.4')
// Answer: 12.3

// Question: What is the value of Math.max([2,3,4,5]);  
// Answer: NaN
//it should be Math.max(1,2,3,4,5)

// Question: typeof(NaN)
// Anwser:"number"

// Question:null == undefined
// Answer: true

// Question: If var a = 2, b =3 what would be value of a && b
// Answer: 3

// Question: What is -5%2
// Answer:-1. the result of remainder always get the symbol of first operand
======================================================================================================================================================================
let a = [];
let b = [];
console.log(a==b); //false
console.log(a===b); //false
//Explaination : Here we are comparing memory location, not an array. Memory location of 2 arrays are not same.
--------------------------
let a = [];
let b = a;
console.log(a==b); //true
console.log(a===b); //true
//Explaination : Here we are assigning a to b, where memory location is now same.
---------------------------
let a = [1];
let b = [1];
console.log(a[0]==b[0]); //true
console.log(a[0]===b[0]); //true
//Explaination : Here we are comparing elements inside an array, not a memory location. We specify the index so that's why element get compared.
-----------------------------
       // 1 2 3 
//Explaination : ...z means destructing happened i.e, all the elements are come out from an array/object.
------------------------------
console.log(typeof NaN); //number
//Explaination : If we divide "priya"/2 then it will give NaN. 
--------------------------------
let data = 10 - -10;
console.log(data); //20
//Explaination : Minus minus will become plus so 10+10=20
---------------------------------
const set = new Set([1,1,2,2,3,4,5])
console.log(set) //{1,2,3,4,5}
console.log(Array.from(set))  // [1,2,3,4,5]
//Explaination : It will remove duplicate values.
---------------------------------
let data ={name: "priya"}
console.log(delete data.name); //true
console.log(data)//{}
//Explaination : delete will return either true or false.
-----------------------------------
// Question 
To check whether num is even or odd without using loop
function checkNumber(num){
    const check = ['even', 'odd'];
    console.log(`${num} is ${check[num%2]}`);
}
checkNumber(6); // 6 is even
checkNumber(5); // 5 is odd
-------------------------------------
let data ={name: "priya"}
console.log(delete data); 

//answer -> false
//Explaination : We can delete the object property only i.e. delete data.name will work, but We can't able to delete the object(i.e, data).
------------------------------------
const data = ["piya", "priya", "supriya"];
const [y] = data;
console.log(y); //"piya"
//Explaination : We are doing destructuring here. y is representing the first index only
-------------------------------------------
var obj = {
    name : 'Sourabh',
    sports : ['Chess', 'Football', 'Snooker']
}

var mySports= obj.sports.slice();    //slice creates a new reference/array of the sports array. 
console.log(mySports, obj.sports)     //[ 'Chess', 'Football', 'Snooker' ] , [ 'Chess', 'Football', 'Snooker' ] 
obj.sports.push('Bowling');          //pushes to obj only
console.log(mySports, obj.sports)     // [ 'Chess', 'Football', 'Snooker' ] , [ 'Chess', 'Football', 'Snooker', 'Bowling' ]
mySports.add('cricket')       	      
console.log(mySports,obj.sports)     //[ 'Chess', 'Football', 'Snooker', 'cricket' ],  [ 'Chess', 'Football', 'Snooker', 'Bowling' ]

any changes made to the original or the array created by slice does not affect any other array
--------------------------------------------------------------------------------------
const data = ["piya", "priya", "supriya"];
const [y,z] = data;
console.log(y,z); //"piya", "priya"
//Explaination : We are doing destructuring here. y is representing the first index only and z representing the second index.
--------------------------------------------------------------------
const data = ["piya", "priya", "supriya"];
const [,m] = data; // way to access any specific element here at second position
console.log(m); //"priya"
//Explaination : To access any element without taking previous values, we can do just write comma.
----------------------------------------------------------------------
const data ={name:"priya"}
const {name} = data; //how to get the name property without . dot operator
console.log(name);//priya
//Explaination : Here we did object destructuring.It's not store in continuos memory location but array store in continuoes memory location so that's why we used comma in an array.
---------------------------------------------------------------
let data ={name:"priya"}
let data1={city:"ABC"}
data = {...data, ...data1} //merge 2 objects
console.log(data); // {name:"priya", city:"ABC"}
//Explaination : using spread operator we use to merge the 2 objects. Three dots will pop out the property from an object and assign inside curly brackets.
-----------------------------------------------------------
let data ={name:"priya"}
let data1={city:"ABC"}
data = {data, ...data1} //merge 2 objects
console.log(data); // { "data" : {name:"priya"}, "city": "ABC"}
//Explaination :Three dots will pop out the property from an object and assign inside curly brackets. If we didn't do destructing or spread operator then key will be object name(i.e, data) and assign the value as whole object into it.
---------------------------------------------------------
let data ={name:"priya"}
let data1={city:"ABC", name: "supriya"}
data = {...data, ...data1} //merge 2 objects
console.log(data); // { name:"supriya", "city": "ABC"}
//Explaination : If we have same keys while merging then the position of the property will remain same but the value get updated with new value. Because in an objects Keys hould be unique.
-------------------------------------------
const name = "priya"
console.log(name()); //Error: name is not a function
//Explaination : Function we are calling but it's not present so it will an error.
--------------------------------------------
const result = false || {} || 20 || null;
console.log(result); //20
//Explaination : OR operator will find first positive value. Null is a falsy value by default. {} is a positive value. It didn't reach till 20 and null.
--------------------------------------------
const result = null || false || '';
console.log(result); //''
//Explaination : OR operator will find first positive value. It will print '' because any of the true value didn't found so it will pick last value always.
-------------------------------------------
const result = [] || 0 || true;
console.log(result); //[]
//Explaination : OR operator will find first positive value. It will print [] because empty array/object is a positive.
-------------------------------------------------
console.log(Promise.resolve(5)); //Promise {<fulfilled>: 5}
//Explaination : While doing resolve(), itself here a promise. If we pass number/string etc then it will print fulfilled.
------------------------------------------------
console.log("smile" === "smile"); //true
//Explaination : Each emojy contain unicode where we are compairing unicode not the emojy so it's true
-------------------------------------------------
JSON.parse ?
Parse JSON object to a JavaScript value // converting data into js object
-------------------------------------------------
let name  = "priya";
function getName(){
  console.log(name); //Uncaught ReferenceError: Cannot access 'name' before initialization 
  let name = "supriya";
}
getName();
//Explaination : Hoisting used here. If we use VAR the can use variable before declare. But in LET we can't do that. LET/CONST need declaration first then can use it.
--------------------------------------------------
let name  = "priya";
function getName(){
  console.log(name); //Uncaught ReferenceError: Cannot access 'name' before initialization 
  let name = "supriya";
}
getName();
------------------------------------------------------------------------------
let name  = "priya";
function getName(){ 
  let name;
  console.log(name); //undefined
  name = "supriya";
}
getName();
------------------------------------------------------------------------------
let name  = "priya";
function getName(){ 
  let name = "supriya";
  console.log(name); //supriya    
}
getName();
------------------------------------------------------------------------------
let name  = "priya";
function getName(){
  console.log(name); //priya
}
getName();
//Explaination : Let is a block scope.Because of closures we can able to access name which is outside of a function with LET.
--------------------------------------------------
console.log((x => x)('I love')) //"I love"
console.log(`${(x => x)('I love')} to program`) //"I love to program"
//Explaination : Template Literal used here. We use here arrow function which is returning a string 
----------------------------------------------------
function sumValues(x,y,z){
  return x+y+z;
}
sumValues(...[2,3,4]) 

//how to call a function so that output will be 9
//Explaination : we can't do like this sumValues(2,3,4).
----------------------------------------------------
const name = "priya is a girl.";
console.log(typeof name); //string
console.log(!typeof name); //false //"priya is a good girl" is a string means thruthy value. Nagation of thruthy is falsy value.
console.log(!typeof name === 'object'); //false
console.log(!typeof name === 'string'); //false
console.log(!typeof name === false); //true
//Explaination : We are using negation mark(!) which will return either true or false only.
----------------------------------------------------
const name = "priya";
const age ="10000";
console.log(isNaN(name)); //true
console.log(isNaN(age)); //false
//Explaination : If it's not a number then return True. If it's a number then return false.
-----------------------------------------------------
let person = {name: "priya"};
Object.seal(person); //post seal, how can you modify the person object
person.age ="1000";
person.name ="supriya";
console.log(person); //{name : "supriya"}
//Explaination : Onceyou use Seal we can't able to add the more keys with values into it.But you can modigy the existing key.
-------------------------------------------------------
let data = [2,9,0,10];
data.shift();//remove first element
console.log(data); //[9,0,10]
data.pop(); //remove last element
console.log(data);//[9,0]
//Explaination : shift and pop use to remove the elements from first and last index.
--------------------------------------------------------
//check the value is even or odd
let a =10;
console.log(a%2===0 ? true : false); //true
//Explaination : Need to divide by 2 and then checking if reminder is zero/one.
----------------------------------------------------------
let data ={ name : "priya"};
delete data.name;
console.log(data); //{}
//Explaination : delete always work with object properties not a object itself.
---------------------------------------------------------
let data ="true";
//convert data into boolean false value
console.log(!data); //false
console.log(typeof !data); //boolean
//Explaination : ! will make boolean value(or opposite value). 
---------------------------------------------------------
let data ="true";
//convert data into boolean true value
console.log(!!data); //true
console.log(typeof !!data); //boolean
//Explaination : !! will make boolean value and ! will make opposite.. 
---------------------------------------------------------
Diff between Map and foreach: Map will return new thing but Foreach didn't return anything.
---------------------------------------------------------
let data = ["piya", "priya", "supriya"];
delete data[1];
console.log(data); //["piya",,"supriya"] //["piya",empty,"supriya"]
console.log(data.length); //3
//Explaination : Whenever element deleted from an object it will create a empty space. Array length will always reain same.
-------------------------------------------------------------
//merge 2 arrays
const a =[1,2,3];
const b =[4,5,6];
const c =[...a, ...b]
console.log(c); //[1,2,3,4,5,6]
//Explaination : using spread operator
----------------------------------------------------------------
const a =[1,2,3];
const b =[3,4,5,6];
const c =[...a, ...b]
console.log(c); //[1,2,3,3,4,5,6]
//Explaination : using spread operator still we can merge and both values will be present in arrays. But in an object, it will take the lates value and assigned to the 1st position of that key.
-------------------------------------------------------------------
let c = 3**3;
console.log(c); //27
console.log(3*3); //9
//Explaination : 3 square 3 means 3*3*3
---------------------------------------------------------------------
let a=2;
setTimeout(()=>{
  console.log(a); //100
},0)
a=100;
//Explaination : Here we are using zero time interval. setTimeout is async function so it will execute at last. Firstly all the sync code will get execute. so that's why 100 is assigned to a.
------------------------------------------------------------------------
let a =2;
let A =30;
console.log(A); //30
//Explaination : a and A both are diff variables.
------------------------------------------------------------------------
let A10="hello";
let 10A ="hi";
console.log(A10); //hello
//console.log(10A); //error
//Explaination : Variable can't start with a number.
------------------------------------------------------------------------
let a="hello";
let b =`hello`;
console.log(a === b); //true
console.log(a == b); //true
//Explaination : Doble code and backticks both are same.
--------------------------------------------------------------------------
let a =1;
let c =2;
console.log(--c === a); //true
//Explaination : --c will be 1 so thats why true.
--------------------------------------------------------------------------
let a =1;
let b =1;
let c =2;
console.log(a === b === -c); //false
//Explaination : a===b gives True. true === -c(number) gives false.
---------------------------------------------------------------------------
console.log(3*3); //9
console.log(3**3); //27
//console.log(3***3); //error
//Explaination : *** doesn't exist in js.
----------------------------------------------------------------------------
console.log(a); //undefined
var a;
//Explaination : We can use VAR variable before its declaration. We didn't assign any value but still by default "undefined" will be store in it.undefined means declared but value didn't initialised.
-----------------------------------------------------------------------------
console.log(a); //not defined
//Explaination : Not defined means variable didn't even declared.Also value is not assogned.
-----------------------------------------------------------------------------
console.log([[[]]]); //[[[]]]
//Explaination : It will print the nested array. We will get 3 nested array and each one have 1 element but at the last array will be empty.
------------------------------------------------------------------------------
How to find Operating system name?
navigator.plateform we can use it. //win32
-------------------------------------------------------------------------------
let for = 100; //Error
//Explaination : For is a reserved keyword.
-------------------------------------------------------------------------------
function fruit(){
  console.log(name); //undefined
  console.log(price); //Error
  var name = "priya";
  let price = 1000;
}
fruit()
//Explaination : Hoisting concept used here. Error because in LET declaration first then only we can use it. but in var we can use brfore its declaration.
-------------------------------------------------------------------------------
for(var i=0; i<3; i++){ 
  setTimeout(()=>console.log(i),1) // 3,3,3
}

for(var i=0; i<3; i++){ 
  setTimeout((i)=>console.log(i),1) // 0,1,2
}

//i=0 //1 //2 //3
//Explaination : Var is a global variable. Firstly Sync code get executed then async code will start to execute. so i value incremented from 0 to 3 when pointer reaches to setTimeout so it will print 3 thrice time.
---------------------------------------------------
for(let i=0; i<3; i++){ //i=0 //1 //2 //3
  setTimeout(()=>console.log(i),1) //0 //1 //2
}
//Explaination : LET is a block scope. so it will print 0,1,2. Its having own islocated scope.
----------------------------------------------------
console.log(+true); //1
console.log(typeof +true); //number
//Explaination : if we write + in front of anything then it will convert into a number.
----------------------------------------------------
console.log(!"priya"); //false
console.log(typeof ("priya")); //string
//Explaination : ! will give either true/false.! means false and !! means true.
----------------------------------------------------
let data = "size";
const bird = {size : "small"}
console.log(bird[data]); //small
console.log(bird["size"]); //small
console.log(bird.size); //small
console.log(bird.data); //undefined
//Explaination : If we wants to access variable with object then use [] notation(. notation will not work).
------------------------------------------------------
let c = {name  : "priya"};
let d;
d=c;
c.name = "supriya";
console.log(d.name); //supriya
//Explaination : Using assignment operator we are accessing the same memory allocation. 
-------------------------------------------------------
var x;
var x=10;
console.log(x); //10
//Explaination : Can be declare multiple times.
---------------------------------------------------------
var x;
let x=10;
console.log(x); //Error
//Explaination : Can't be declare multiple times with LET.
----------------------------------------------------------
let a = 3;
let b = new Number(3);
console.log(a == b); //true
console.log(a === b); //false
console.log(typeof b); //object
//Explaination : === will give false because a will give number but b will give an object.
-------------------------------------------------------
let name;
nmae ={}; //wrong variable name i wrote
console.log(name); //undefined
//Explaination : by default it wil be undefined if we declare first.
---------------------------------------------------------
function first(){
  console.log("Woof!!"); //Woof!!
}
first.name = "apple";
first();
//Explaination : To add the property with a function then it will not create a impact.
----------------------------------------------------------
function sum(a,b){
  return a+b;
}
console.log(sum(1, "2")); //12
//Explaination : 2 is passed as a string so it will get concat. num+string = string
------------------------------------------------------------
let num = 0;
console.log(num++); //0
console.log(++num); //2
console.log(num); //2
//Explaination : ++ will increase the value by 1. preincrement and postincrement used here.
--------------------------------------------------------------
function getAge(...args){ 
  console.log(typeof args); 
}
getAge(1000);

//args = [1000]  ans -> object
//Explaination : typeof args means typeof an array means typeof [] is object.
--------------------------------------------------------------
function getAge(){ 
 age = 1000;
 console.log(age); 
}
getAge();

//1000
//Explaination : if we didn't declare with Var/Let/const then by default it will become as a Var.
------------------------------------------------------------------
function getAge(){ 
  'use strict'
 age = 1000;
 console.log(age); 
}
getAge();

//error
//Explaination : Use strict wil give a error because it forces to use a proper way of the variable declaration.
----------------------------------------------------------------------
const sum = eval('10*10+5');
console.log(sum);

//105
//Explaination : It will perform the numerical operation
----------------------------------------------------------------------------
const obj = {1:"a", 2:"b"}
console.log(obj.hasOwnProperty("1")); //true
console.log(obj.hasOwnProperty(1)); //true
//Explaination : "1" and 1 treat as same.
----------------------------------------------------------------------------
const obj = {a:"one", b: "two", a:"three"}
console.log(obj); 

// {a:"three", b: "two"}
//Explaination : Key position will be same but tha value get updated with new value in object.
----------------------------------------------------------------------------
for(let i=1; i<5; i++){
  if(i==3) continue;
  console.log(i); 
}

//1,2,4
//Explaination : If i =3 then it will not execute the code for 3, but can execute for i=4.
------------------------------------------------------------------------------
const foo = () => console.log("first");
const bar = () => setTimeout(()=> console.log("second"));
const baz = () => console.log("third");
bar();
foo();
baz();
//Explaination : first,third, second. Because asyn operation work post all the syn operation get complete.
----------------------------------------------------------------------------
<div onClick="console.log("first div")">
  <div onClick="console.log("second div")">
    <button onClick="console.log("button")">
     Click Me
     </button>
  </div>
</div>
//Explaination : button, second div, first div. Even bubbling happened here.
---------------------------------------------------------------------------
const person = {name:'priya'};
function sayHi(age){
  return `${this.name} is ${age}`;
}
console.log(sayHi.call(person,21)); //"priya is 21"
console.log(sayHi.bind(person,21)); //it will return a function. //function sayHi(age){  return `${this.name} is ${age}`;}
console.log(sayHi.bind(person,21)()); //"priya is 21"
//Explaination : Bind will always return a function so require to invoke the function.
------------------------------------------------------------------------------
let greeting = {
    message: 'Good morning!', 
    name: 'Sourabh',
	displayMessage() {
        console.log(`Hello ${this.name}, ${this.message}`);
    }
};
setTimeout(greeting.displayMessage, 1000);;      // Hello Undefined Undefined

solutions: 
--------------------------------------------
1.

let greeting = {
    message: 'Good morning!', 
    name: 'Sourabh',
displayMessage() {
        console.log(`Hello ${this.name}, ${this.message}`);   
    }
};
setTimeout(function() {
  greeting.displayMessage();               
}, 1000);  

//Hello Sourabh Good Morning!!
//This will work because it receives greeting from the outer lexical environment, and then calls the method normally.

2. 
let greeting = {
    message: 'Good morning!', 
    name: 'Sourabh',
    displayMessage() {
        console.log(`Hello ${this.name}, ${this.message}`);
    }
};
let welcomeMessage = greeting.displayMessage.bind(greeting);
setTimeout(welcomeMessage, 1000);   

// Hello Sourabh Good Morning!!

//Here we take the method greeting.displayMessage and bind it to greeting. The displayMessage is a “bound” function, that can be called alone or passed to setTimeout (doesn’t matter, the context will be right).
------------------------------------------------------------------------------
function sayHi(){
  return (()=>0)();
}
console.log(typeof sayHi()); //number
//Explaination : sayHi will return anonymous arrow function/IIFE, where it will return 0. type of 0 is number.
----------------------------------------------------------------------------
function sayHi(){
  return ()=>0;
}
console.log(typeof sayHi()); //function
console.log(typeof sayHi()()); // number
//Explaination : sayHi will return anonymous arrow function/IIFE, where we didn't invole the arroe function so it will return function.
-----------------------------------------------------------------------------
console.log(typeof typeof 1); //string
//Explaination : typeof 1 is a number and typeof number is a string.
-----------------------------------------------------------------------------
const numbers = [1,2,3];
numbers[6]=11;
console.log(numbers); //[1,2,3,(3 empty items), 11]
		      //[0,1,2,_,_,_,11]
//Explaination : Array store elements in a continuous memory location. It will give empty in between an array.
-------------------------------------------------------------------------------
const numbers = [1,2,3];
numbers[9]=numbers;
console.log(numbers);

//[1,2,3,(6 empty items), [1,2,3] ....infintitely]
//Explaination: It will print infinite loop because setting array....
-------------------------------------------------------------------------------
console.log(!!null); //false
console.log(!!""); //false
console.log(!!1); //true
//Explaination: !null give true and !!null give false. !1 give false and then !!1 give true.
-------------------------------------------------------------------------------
console.log(setInterval(()=>console.log('Hi'), 1000));
console.log(setInterval(()=>console.log('Hi'), 1000));
console.log(setInterval(()=>console.log('Hi'), 1000));
//Explaination: setInterval will give uniques id to stop. It will give like 1,2,3. so it will print 1,2,3,Hi,Hi, Hi, Hi, Hi, .....so on.
------------------------------------------------------------------------------
console.log(setTimeout(()=>console.log('Hi'), 1000));
console.log(setTimeout(()=>console.log('Hi'), 1000));
console.log(setTimeout(()=>console.log('Hi'), 1000));

//Explaination : it will print unique identifier because the setTimeOut will not wait. it will move to next... 1,2,3,Hi,Hi, Hi.
-------------------------------------------------------------------------------
console.log([..."priya"]); //["p","r","i","y","a"]
//Explaination: It will convert string "priya" into an array, equal to [...string]
-------------------------------------------------------------------------------
const firstPromise = new Promise((res, rej)=>{
  setTimeout(res, 500, 'one');
})
const secondPromise = new Promise((res, rej)=>{
  setTimeout(res, 100, 'second');
})
Promise.race([firstPromise, secondPromise]).then(res => console.log(res));  //second
//Explaination: Race will return only first matching result so it will print 100. For 500 it will take time to execute so it will not get print.
-----------------------------------------------------------------------------------
let person = {name: "priya"};
const numbers = [person];
person = null;
console.log(numbers, person); // [{name : "priya"}] //null
//Explaination: We try to empty the objecti,e person, but still an array i.e, numbers conatin value so it will not create an impact while assigning null to person.
----------------------------------------------------------------------------------
const person = {name: "priya", age: 1000};
for(const item in person){
  console.log(item); //name, age
}
//Explaination: For in loop give a keys only.
--------------------------------------------------------------------------------------
let data = 3+4+'5';
console.log(data); //"75"
console.log(typeof data); //string
//Explaination: It will add as a string.
------------------------------------------------------------------------------------------
console.log(typeof 3+4+'5'); //"number45" type=string
//Explaination: operation went from left to right side.
----------------------------------------------------------------------------------------
console.log(typeof (3+4+'5')); //"75" //string
console.log(typeof (3+4+  +'5'));//number
//Explaination: To find out the typeof when the all the operation get complete thrn have to enclose in paranethisis. If we add + plus sign to any string it will convert to a number.
----------------------------------------------------------------------------------------
let data = [1,2,3].map( num =>{
  if (typeof num === 'number') return;
  return num*2;
})
console.log(data); 

//[undefined,undefined,undefined]
//Explaination: If just return then it will print undefined.
----------------------------------------------------------------------------------------
function getInfo(member){
  member.name = "priya";
}
const person = {name : "supriya"}
getInfo(person);
console.log(person); //{"name":"priya"}

//Explaination: overwrites, If we pass an object as argument it will have call by refrence, means having same memory location.
----------------------------------------------------------------------------------------
function Car(){
  this.make = "tata";
  return {make: "kia"};
}
const myCar = new Car();
console.log(myCar.make); 

//kia
//Explaination: return will overrite the property.If we didn't return then it will print tata.
----------------------------------------------------------------------------------------
(()=>{
  let x = (y = 10);
})()
console.log(typeof x, y); //"undefined" //10
//Explaination: x is a block scope, and we are trying to console x outside of x so that's why undefined.
-----------------------------------------------------------------------------------------
(()=>{
  let x = y = 10;
})()
console.log(typeof y); 

//number
//Explaination: x is a block scope, and y is a var because y is not declared so by default it will be var.
----------------------------------------------------------------------------------------
(()=>{
  let x = 10;
})();
(()=>{
  let x = 10;
})();
console.log(typeof x); //undefined
//Explaination: x is a block scope.
---------------------------------------------------------------------------------------
(()=>{
  let x = y = 10;
})();
(()=>{
  let x = y = 20;
})();
console.log(y); 
// x = undefined, var y = 10 --> 20 
//Explaination: y is a var scope so it will overrite from 10 to 20
-----------------------------------------------------------------------------------------
let x =100;
(()=>{
  var x = 10;
})();
console.log(x); 

//100
//Explaination: x=10 contain inside a block because we already declare with 100 outside so it will print 100.
-------------------------------------------------------------------------------------------
const func = (function(a){
                   delete a;
                   return a;
               } )(5)
console.log(func);

output: 5
//delete keyword only use with object properties. here a is a variable so it will not work the variable. //delete user.age 
------------------------------------------------------------------------------------------
Dynamic property of object :
const property = "firstName";
const name = "Priya";

const user = {
  property : name 
}
console.log(user);

const user1 = {
  [property] : name 
}
console.log(user1);

////{"property" : "Priya"} ,{"firstName" : "Priya"}  -->  dynamic property required [] //
------------------------------------------------------------------------------------------
const user ={
  name : "priya",
  age : 100
}

//iterate through keys
for(let item in user){
  console.log(item) //name age
}
//iterate through values
for(let item in user){
  console.log(user[item]) //priya 100
}
------------------------------------------------------------------------------------------
const user ={
  name : "priya",
  age : 100
}

//double the age as 200 //iterate through keys
for(let item in user){
 if(typeof user[item] === "number"){
   user[item]*=2
 }
}

console.log(user)

//{ name: 'priya', age: 200 }
------------------------------------------------------------------------------------------
const a = {}
const b = {key : "b"}
const c = {key : "c"}

a[b] = 123;
a[c] = 456;
console.log(a[b]); //456

//console.log(a) //{"[object Object]" : 456}
//here object is not converted into a string so printing key as object Object.
//so for both it will be 
//a["[object Object]"] = 123;
//a["[object Object]"] = 456;
//it get override by 456.
------------------------------------------------------------------------------------------
const user = {
  name :"priya",
  age : 100
}
//convert into a string
const str = JSON.stringify(user)
console.log(str)//{'name':'priya','age':100}"

//convert string onto an object
console.log(JSON.parse(str)) //{ name : "priya, "age":100}

-------------------------------------------------------------------
*****************
Real Usecases : Storing in local storage. We can't store the object as a value so require to convert into a string.
const user = {
  name :"priya",
  age : 100
}
console.log(JSON.stringify(user)) //convert into a string
console.log(JSON.parse(JSON.stringify(user)))  //convert into an object

localStorage.setItem("testAsKey", JSON.stringify(user)) {"name":"priya","age":100}
localStorage.setItem("testAsKey", user) //[object Object] beacuse we are forcefully trying to convert in a string

JSON.parse(localStorage.getItem("testAsKey")) //will get as a object
------------------------------------------------------------------------------------------
const user = {
  name :"priya",
  age : 100
}
console.log(JSON.stringify(user,["name"])) 

//"{'name':'priya'}"

//wheen we pass as a array then it will convernt only those properties and ignore rest of the proerties
------------------------------------------------------------------------------------------
const shape = {
  radius : 10,
  diameter(){
    return this.radius*2; //this pointing to shape
  }
 parimeter : () => 2*Math.PI*this.radius; //this pointing to window where it's not exist
}
console.log(shape.diameter()) 
//console.log(shape.parimeter()) 


// 20 NaN
anything * + - / defined will give NaN
-------------------------------------------------------------------------------------------
let user = {
  name : "Priya",
  age : 100
}

const name = "Supriya";
//const {name} = user; //Identifier 'name' has already been declared 
const {name : myName} = user;

console.log(myName)

//Priya
-------------------------------------------------------------------------------------------
let user = {
  age : 100,
  fullName : {
    first : "Priya",
    last : "Bagde"
  }
}

const {fullName : {first}} = user;
console.log(first); 

//"Priya"
//Destructuring at deep nested
-------------------------------------------------------------------------------------------
let c = {greeting : "Hey!"}
let d;

d=c;
c.greeting = "Hello"
console.log(d.greeting); //Hello

//We are passing the refrence not the propertues of an object so when we changge the roperty of any object it will reflect in both objects
-------------------------------------------------------------------------------------------
let person = {name : "priya"}
const members = [person]
person = null
console.log(members); 


[{"name":"priya"}]

let person = {name : "priya"}
const members = [person]
person.name = null
console.log(members);

// [{"name":null}]

//anything either obj or arr or array of object will be null, if we do obj =null directly. but already consumed to some other obj will not be null
//because we are modifying the property of object
-------------------------------------------------------------------------------------------
Ways to make deep copy:
1. object.assign   // one level deep, nested shallow
2. {...obj}   //  one level deep, nested shallow
3. JSON.parse(JSON.stringyfy(obj))  // deep
-------------------------------------------------------------------------------------------
console.log(1);

function print(name){
  setTimeout(()=>{
    return `${name}`
  },1000)
}
let value = print("Priya");
console.log(value)

console.log(2);

//1 undefined 2
Reason : It run the code quickly and it will not wait for setTimeout so value will be undefined
---------------------------------------------------
Above code can be fix by callback:
console.log(1);
function print(name, callback){
  setTimeout(()=>{
     callback(name)
  },1000)
}
print("Priya", (value)=>{
  console.log(value)
});
console.log(2);
-------------------------------------------------------------------------------------------
let promises = new Promise((resolve, reject)=>{
  setTimeout(()=>{
    let state = true;
    if(state){
      resolve("Resolved Promises!!...");
    }else{
      reject("Rejected Promises!!...");
    }  
  }, 1000)
})
promises.then((res)=>console.log(res))
.catch((err)=>console.log(err))

//Resolved Promises!!...
-------------------------------------------------------------------------------------------
console.log(1);

const data = new Promise((resolve, reject)=>{
  console.log(2);
  resolve(3);
})

data.then((res)=>{
  console.log(res)
})

console.log(4); 

//1 2 4 3
-------------------------------------------------------------------------------------------
console.log(1);

const data = new Promise((resolve, reject)=>{
  console.log(2);
})

data.then((res)=>{
  console.log(res)
})

console.log(4);

//1 2 4 
If we are not returning anything it will not print anything .
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
let a = "true";
setTimeout(()=>{
  a=false;
}, 2000)

while(a){
  console.log("1")
} 

Reason: 1, 1, 1,...... 
Explanation: Event loop will add setTimeout callback in Macrotask queue and will push it to call stack for execution only when the main thread finishes executing.

Here, since 'a' is true and isn't being set to false anywhere in main thread, the while loop will run infinitely, and setTimeout callback will never get a chance to run.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function run(value, time){
  return new Promise((resolve)=>{
    setTimeout(()=>{
      resolve(value)
    }, time)
  })
}
async function task(){
  let a = await run(1, 1000); //1value //1 sec
  let b = run(2, 2000); //2value //2 sec
  let c = run(3, 1000);  //3value //execute before b so will not take extra time
  console.log(a + await b+ await c);
}
task()

6 'in 3 Sec'

Explanation: In line 10, a setTimeout() timer of 1 sec will be triggered and due to 'await', it will wait for the timer to expire, and after 1 sec, value of a is 1. 

Then since there is no 'await' in line 11 and 12, the 2 timers of 2 sec and 1 sec will be triggered simultaneously. Then in line 14, since b hasn't been resolved, due to await, it will wait for another 2 sec, and since the 2 timers started simultaneously, the other 1 sec timer would already have expired. 

So, after another 2 sec, value of b will be 2, and then immediately after that, value of c will be 3. 

👉 Output : 1 + 2 + 3 = 6
👉 Total time: 1 (line 10) + 2 (await b, in line 14) + 0 (await c, in line 14) = 3 sec
---------------------------------------------------------------------------------------------------------
let date = new Date(95, 3);
console.log(date.toLocaleString('default'));

It prints “4/1/1995, 12:00:00 AM”. When only a year is provided, it maps to the 20th century. Also, January is month 0. Therefore, new Date(95, 3) creates a Date object set to April 1995.

------------------------------------------------------------------
const fetchData = function(){
  return new Promise((res, reject)=>{
    reject("Error!!")
  })
}

fetchData()
.then(null, (err)=>{
  console.log("First");
  console.log(err);
})
.catch(()=>{
  console.log("Second");
  console.log(err)
})

Explaination : "First" "Error!!"
//happening due to middleware present inside then
reject("Error!!") gives string value so it will go to THEN block rather than CATCH block.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
displayName();
var displayName = function(){
  console.log("Priya")
} 
function displayName(){
  console.log("dolly")
}
displayName();

//Explaination : dolly priya

Normal function will get execute before, because of function Hoisting concept, then function expression wil get execute.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
const inc = async(x) => {
  x = x + await 1; //2
  return x;
}

const increment = async(x) =>{ 
  x = x+1; //2+1
  return x; //3
}
inc(1)
.then((x)=>{ //2
  increment(x) //2
  .then((x)=>console.log(x)) //3
})

//  3
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
const p1 = Promise.resolve("First");
const p2 = Promise.reject("Second");
const p3 = Promise.resolve("Third");
const runPromise = async() =>{
  try{
    const res = await Promise.all([p1,p2,p3]);
    console.log(res);
  }
  catch(err){
    console.log(err)
  }
}
runPromise();

//output : Second

Promise.all() returns array of resolved promises values and if either any of the promise is rejected, then it directly returns the rejected promise value through catch block.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
console.log("start");

async function getData(){
  console.log("priya");
  return "Dolly";
}

getData()
.then((res)=> console.log(res));

console.log("end");
//start priya end Dolly
//all the console will print first then aync and setTimeout
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
function promise(){return new Promise((resolve)=>resolve('success'))}

function first(){
    console.log('first')
    promise().then((res)=>console.log(res))
    console.log('done in first')
}

async function second(){
    console.log('second')
    const res = await promise()
    console.log(res)
    console.log('done in second')
}

first()
second()

// it has to wait for async await to finish execution as it will block the code.
//await pause the line of execution

// first, done in first, success second, success, done in second
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
const person1 = {
  name : "Priya"
}
const person2 = {
  name : "Dolly"
}
const person = Object.assign(person1, person2);

console.log(person);
console.log(person.name); 
console.log(person1.name); 
console.log(person2.name); 

// {"name" : "Dolly"} Dolly Dolly Dolly
//Having same key name so, the value is override and it will be "Dolly"

Explanation : As Object.assign() method will add all the key values of person2 to person1 and return the reference of person1 to person and if same key are there they'll be overwritten.
Basically person1 and person are referring to same object.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
// currying with infinite arguments
const calc=(a)=>{
  return (b)=>{
    if(b) return calc(a+b);
    return a;
  }
}
console.log(calc(1)(2)(3)(4)()) //10 currying
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
const fetchData = function(){
  return new Promise((res)=> res("One"));
}

//Tip!! always start skimming the code and skip async code and go below till end, if find sync code then execute it first, then come back to sync code

let isLoading = true;
fetchData()
.then((result)=>{
  console.log(result);
})
.finally(()=>{
         console.log("Two");
          isLoading = false;
})      
console.log(isLoading)  

//true one two
//console value run first
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

const person = {
  name : "Priya",
  displayName(){
    console.log(this.name) //pointing to the person object
  }
}

const jayesh = Object.create(person)    // Object.create creates a new empty object which will inherit from the prototype.
person.displayName(); //Priya
console.log(jayesh); //{}
jayesh.displayName(); //Priya
I believe Object.create() creates a new object from the existing object, and both have the same memory addresses.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
let p = new Promise((resolve, reject)=>{
   reject(Error("Failed!!"))   --> throwing Error                 
})

p.catch((error)=>{
  console.log(error); //{} This will show the Error Object in the console statetement
  console.log(error.message); //failed
}).then((result)=>{
  console.log(result) //undefined //doesn't return anything
})

//Failed!! undefined
Explanation: In line 2, we are rejecting the promise 'p' with the argument as Error("Fails!"), which is an 'Error' object with property 'message' set to 'Fails!'. So, in line 5, the error callback passed to catch() method of promise 'p' receives the above passed Error object as the 'error' parameter, and so 'error.message' (Fails!) is printed. 

Now, as this catch handler is not returning any value so, the chained 'then' handler will be called with undefined as parameter.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
/* 💡"JavaScript-with-JC" - Guess the Output? */

// 👉 MCQ-1
function MCQ1() {
  const person = {
    name: "Jayesh",
    displayName1: function () {
      console.log("name1", this.name);
    },
    displayName2: () => {
      console.log("name2", this.name);
    },
  };
  person.displayName1();
  person.displayName2();

  // 👍A) name1 Jayesh , name2 Jayesh
  // 💡B) name1 Jayesh , name2 undefined
  // 💖C) name1 Jayesh , name2
  // 😀D) name1 , name2 Jayesh

  /* 
  In window browser answer is C) name1 Jayesh , name2 because arrow function inherits "this" from its outer function where "this" is window.
  and window has by default property name that is used for setting or returning the name of a window and in above case window.name is empty string.
  
  In other compilers answer is B) name1 Jayesh , name2 undefined because arrow function inherits "this" from its outer function where "this" refers to global object.
  */
}
// MCQ1();

// 👉 MCQ-2
function MCQ2() {
  let name = "Jayesh";
  function printName() {
    if (name === "Jayesh") {
      let name = "JC";
      console.log(name);
    }
    console.log(name);
  }
  printName();

  // 👍A) Jayesh     💡B) Jayesh, JC
  // 💖C) JC, JC     😀D) JC, Jayesh

  /* Answer is D) JC, Jayesh because let variables are block scope, name inside if condition will shadow outer name*/
}
// MCQ2();

// 👉 MCQ-3
function MCQ3() {
  var player = "Virat";
  function displayPlayer() {
    if (player === "Virat") {
      var player = "VK";
      console.log(player);
    }
    console.log(player);
  }
  displayPlayer();

  // 👍A) VK, Virat    💡B) VK, VK
  // 💖C) undefined    😀D) VK, undefined

  /* 
   Answer is C) undefined because var variables are functional scope, When displayPlayer fn starts executing, Execution context of
   displayPlayer will be created in callstack and at the memory creation phase var variable player is initialized as undefined. 
   hence if condition will become false and It will print only undefined.
  */
}
// MCQ3();

// 👉 MCQ-4
function MCQ4() {
  const person = {
    name: "Jayesh",
    age: 24,
  };

  const getAge = person.age;
  delete person.age;

  console.log(person);
  console.log(getAge);

  // 👍A) { name: 'Jayesh', age: 24 }, null
  // 💡B) { name: 'Jayesh' }, 24
  // 💖C) { name: 'Jayesh' }, undefined
  // 😀D) { name: 'Jayesh', age: 24 }, 24

  /*
  Answer is B) { name: 'Jayesh' }, 24 because delete keyword deletes property of an object and we are setting getAge as pass by value.
 */
}
// MCQ4();

// 👉 MCQ-5
function MCQ5() {
  // No Strict Mode
  name = "Jayesh"; // window.name ( property of window object )
  console.log(delete name);

  const displayName = (function (name) {
    console.log(delete name); // Local variable of function
    return name;
  })("JC");

  console.log(displayName);

  // 👍A) true, false, JC
  // 💡B) true, true, undefined
  // 💖C) false, false, JC
  // 😀D) false, true, undefined

  /*
  Answer is A) true, false, JC because delete keyword deletes only property of an object. 
  delete keyword can not delete local variables ( declared with var, let, and const ) and functions. 
  delete keyword can delete global variables as they are property of window object.
 */
}
// MCQ5();

// 👉 MCQ-6
function MCQ6() {
  const arr = [];

  for (var i = 0; i < 5; i++) {
    arr[i] = function () {
      return i;
    };
  }

  console.log(arr[0]());
  console.log(arr[4]());

  // 👍A) 0, 4     💡B) 4, 4
  // 💖C) 5, 5     😀D) TypeError

  /*
  Answer is C) 5, 5 because variables declared with var keyword are function-scoped or globally-scoped but not blocked scoped. 
  Inner function will form the closure and points to the updated value of i that is 5. 
  In the case of Let variable, as they are blocked scoped so inner function will hold different values of i from 0 to 4.
 */

  /* 👇 In the case of Let variable */
  const arrBlock = [];

  for (let i = 0; i < 5; i++) {
    arrBlock[i] = function () {
      return i;
    };
  }

  console.log(arrBlock[0]()); // 0
  console.log(arrBlock[4]()); // 4
}
// MCQ6();

// 👉 MCQ-7
function MCQ7() {
  let person = { name: "Jayesh" };
  const personArray = [person];
  person = null;
  console.log(personArray);

  personArray = [];
  console.log(personArray);

  // 👍A) [ { name: "Jayesh" } ], []
  // 💡B) [ { name: "Jayesh" } ] , TyperError
  // 💖C) [ null ], TypeError
  // 😀D) [ {} ], []

  /*
  Answer is B) [ { name: "Jayesh" } ] , TyperError because person = null will only disconnect the person variable from value { name: "Jayesh"} which is stored in memory, personArray[0] will still point to same value { name: "Jayesh"}.
  and personArray = [] at this line TyperError as const variable can't be redeclared and throws Uncaught TypeError: Assignment to constant variable.  
 */
}
// MCQ7();

// 👉 MCQ-8
function MCQ8() {
  const value = { number: 10 };

  const addition = (x = { ...value }) => {
    console.log((x.number += 5));
  };

  addition();
  addition();
  addition(value);
  addition(value);

  // 👍A) 15, 20, 25, 30    💡B) 15, 15, 20, 25
  // 💖C) 15, 15, 15, 15    😀D) 15, 15, 15, 20

  /*
  Answer is D) 15, 15, 15, 20 because when we call addition function 3rd time with passing value object as an argument, then x will take value as pass by reference and will update number property of original object ( value in this case ) to 15.  
  Hence, while calling addition function 4th time will console 15 + 5 => 20.
 */
}
// MCQ8();

// 👉 MCQ-9
function MCQ9() {
  function makePerson() {
    return {
      userName: "Jayesh",
      ref: this,
    };
  }

  const person = makePerson();
  console.log(person.ref.userName);

  // 👍A) Jayesh      💡B) ""
  // 💖C) undefined   😀D) TypeError

  /*
  Answer is C) undefined because this is not in any method, and also there is no username in function, "this" keyword in makePerson function will refer to the window object,
  person.ref.userName is same as Window.userName and no property named with userName is present in window object, Hence It will console undefined.
 */

  // 👇 We can get "Jayesh" as an output by doing small change in above question :-
  function makePerson2() {
    return {
      userName: "Jayesh",
      // 👇 Here, We have assigned a function to ref property of an object, and function's "this" will point to the returned object.
      ref: function () {
        return this;
      },
    };
  }

  const person2 = makePerson2();
  console.log(person2.ref().userName); // Jayesh
}
// MCQ9();

// 👉 MCQ-10
function MCQ10() {
  const user = {
    userName: "Jayesh",
    displayName: function () {
      console.log(this.userName);
    },
  };

  setTimeout(user.displayName, 1000);

  // 👍A) Jayesh     💡B) undefined
  // 💖C) ""         😀D) TypeError

  /*
  Answer is B) undefined because setTimeout is using user.displayName as a callback function rather than object method.
  callback function's "this" will refer to the window object and It will console undefined as there is no property such as userName in the window object.   
  */

  // 👇 We can get "Jayesh" as an output by wrapping the user.displayName() inside a function :-

  setTimeout(function () {
    user.displayName(); // Here, displayName is called by user object ( object method ). Hence, "this" will refer to user object.
  }, 1000);
}
// MCQ10();

// 👉 MCQ-11
function MCQ11() {
  const series = { name: "JavaScript-with-JC" };

  function getSatus(postNumber) {
    return `${this.name} 🌟 ${postNumber}`;
  }

  console.log(getSatus.call(series, 50));
  console.log(getSatus.bind(series, 50));

  // 👍A) JavaScript-with-JC 🌟 50, undefined
  // 💡B) JavaScript-with-JC 🌟 50, JavaScript-with-JC 🌟 50
  // 💖C) JavaScript-with-JC 🌟 50, [Function: bound getSatus]
  // 😀D) JavaScript-with-JC 🌟 50, TypeError

  /*
  Answer is C) JavaScript-with-JC 🌟 50, [Function: bound getSatus] because call, apply and bind methods are used for function borrowing in JavaScript.   
  The call method immediately invokes the borrowed function where as bind method does not invoke the borrowed function immediately, bind method returns a copy of borrowed function
  that can be called later on with or without passing new arguments to it.
  */

  // 👇 We can get 'JavaScript-with-JC 🌟 50, JavaScript-with-JC 🌟 50' as an output by calling borrowed function of bind method :-

  console.log(getSatus.call(series, 50)); // JavaScript-with-JC 🌟 50
  console.log(getSatus.bind(series, 50)()); // JavaScript-with-JC 🌟 50
}
// MCQ11();

// 👉 MCQ-12
function MCQ12() {
  var name = "Jayesh";

  function displayName() {
    console.log(this.name);
  }

  const person = {
    name: "JC",
    method(fn) {
      fn();
    },
  };

  person.method(displayName);

  // 👍A) JC           💡B) Jayesh
  // 💖C) undefined    😀D) TypeError

  /*
  Answer is B) Jayesh because displayName function is passed to person object method as a callback function.
  "this" keyword in displayName function will refer to window object and window object has a property "name" with value "Jayesh". Hence, It will console Jayesh as an output.
  */

  // 👇 We can get JC as an output by attaching call method with fn() inside person method :-

  const person2 = {
    name: "JC",
    method(fn) {
      fn.call(this); // borrowing function and passing "this" of person2 object.
    },
  };

  person2.method(displayName); // JC
}
// MCQ12();

// 👉 MCQ-13
function MCQ13() {
  var length = 4;

  function callback() {
    console.log(this.length);
  }

  const object = {
    length: 5,
    method: function () {
      arguments[0]();
    },
  };

  object.method(callback, 2, 3);

  // 👍A) 2     💡B) 3
  // 💖C) 4     😀D) 5

  /*
  Answer is B) 3 because arguments keyword is an array of arguments passed to the function. 
  Here while calling object.method(), we are passing three arguments callback fn(), 2 and 3.
  If we try to console arguments it will look like this 👇

  Arguments(3) [ƒ, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
  0: ƒ callback()
  1: 2
  2: 3
  callee: ƒ ()
  length: 3
  Symbol(Symbol.iterator): ƒ values()
  [[Prototype]]: Object

  As we can clearly see, arguments is having length property that is equal to number of arguments passed to function.
  So, arguments[0] is nothing but the first argument passed to function that is callback function in this case.
  As we know, Everything in JavaScript is an object ( arguments is also an object which has length property with value 3 )
  arguments[0]() function's "this" will refer to arguments object. Hence, It will console 3 as an output.
  */
}
// MCQ13();

// 👉 MCQ-14
function MCQ14() {
  var name = "Jayesh";

  function displayName() {
    console.log(this.name);
  }

  const person = {
    name: "JC",
    method: displayName.bind(this),
  };

  person.method();

  // 👍A) Jayesh       💡B) JC
  // 💖C) undefined    😀D) TypeError

  /*
  Answer is A) Jayesh because "this" inside the definition for person object does not refer to person object. 
  "this" will refer to the window object here, and binding displayName function with passing window's this  
  as a context will return a copy of bound function that is stored in method property of person object. 
  So, While calling person.method() will console Jayesh as an output.
  */

  // 👇 We can get JC as an output by wrapping displayName.bind(this) inside a function because "this" inside the normal function of an object refers to the object :-

  const person2 = {
    name: "JC",
    method: function () {
      return displayName.bind(this); // Here, "this" refers to the person2 object
    },
  };

  person2.method()(); // JC
}
// MCQ14();

// 👉 MCQ-15
function MCQ15() {
  function show() {
    console.log(this.name);
  }

  const person1 = { name: "Jc" };
  const person2 = { name: "Jayesh" };

  show = show.bind(person1).bind(person2);
  show();

  // 👍A) Jayesh       💡B) undefined
  // 💖C) JC           😀D) TypeError

  /*
  Answer is C) JC because a function which is bound with bind keyword can not be re-bound with other new context, bind chaining does not exist.
  once the function is bound to a particular object, It will always be bound to that object no matter how many times it's further bounded.
  */
}
// MCQ15();

// 👉 MCQ-16
function MCQ16() {
  let person1 = {
    name: { firstName: "Jayesh" },
    age: 24,
  };
  let person2 = { ...person1 };

  person2.name.firstName = "Virat";
  person2.age = 33;

  console.log(person1.name.firstName);
  console.log(person1.age);

  // 👍A) Jayesh, 33     💡B) Jayesh, 24
  // 💖C) Virat, 33      😀D) Virat, 24

  /*
  Answer is D) Virat, 24 because The spread operator makes deep copies of data if the data is not nested. 
  When we have nested data in an array or object the spread operator will create a deep copy of the top most data 
  and a shallow copy of the nested data. 
  person1 and person2 is pointing to different memory address but person1.name and person2.name is pointing to the same memory address

  We Can do Deep copy of nested objects by using:-
  1) const copyObj = JSON.parse(JSON.stringify(originalObj))
  2) const copyObj = structuredClone(originalObj);
*/
}
// MCQ16();

// 👉 MCQ-17
function MCQ17() {
  for (var i = 0; i < 5; i++) {
    setTimeout(
      (i) => {
        console.log(i);
      },
      1000,
      i
    );
  }

  // 👍A) 0 1 2 3 4      💡B) 5 5 5 5 5
  // 💖C) 4 4 4 4 4      😀D) 0 1 2 3 4 5

  /*
  Answer is A) 0 1 2 3 4 because as we are passing i ( 0 to 4 ) value as an argument to setTimeout callback function
  therefore this will console different values of i from 0 to 4.

  if there was no argument passed to setTimeout callback function then the output would be 5 5 5 5 5 because variables declared 
  with var keyword are function-scoped or globally-scoped but not blocked scoped. Inner function i would point to the updated value of i that is 5.
*/
}
// MCQ17();

// 👉 MCQ-18
function MCQ18() {
  console.log(1);

  async function fetchData() {
    console.log(2);
    let result = await Promise.resolve(3);
    console.log(result);
  }

  fetchData();
  console.log(4);

  // 👍A) 1 2 3 4      💡B) 1 4 2 3
  // 💖C) 1 2 4 3      😀D) 1 3 4 2

  /*
  Answer is C) 1 2 4 3 beacause promise is used to handle the asynchronous result of an operation and 
  callback functions attached to the promises are stored into microtask queue. 
  So, first synchronous code will be executed i.e 1,2,4 and once callstack is empty, event loop pushes the microtask queue's task into callstack
  callstack will start executing the task and It will console 3 at last.
  */
}
// MCQ18();

// 👉 MCQ-19
function MCQ19() {
  console.log("start");

  const promise = new Promise((resolve) => {
    console.log(1);
    resolve(2);
    console.log(3);
  });

  promise.then((result) => {
    console.log(result);
  });

  console.log("end");

  // 👍A) start end 1 3 2      💡B) start 1 3 end 2
  // 💖C) start end 1 2 3      😀D) start 1 end 2 3

  /*
  Answer is B) start 1 3 end 2 beacause The function we pass into the Promise constructor runs synchronously, 
  but anything that depends on its resolution ( resolve or reject ) will be called asynchronously. 
  Even if the promise resolves immediately, any handlers ( callback attached to promise then and catch ) will execute asynchronously. 

  const promise = new Promise((resolve) => {
  console.log(1);  // runs synchronously
  resolve(2); // called asynchronously by then callback
  console.log(3); // runs synchronously
});
*/
}
// MCQ19();

// 👉 MCQ-20
function MCQ20() {
  console.log("First");

  const promise = new Promise((resolve) => {
    console.log("Second");
  });

  promise.then((result) => {
    console.log(result);
  });

  console.log("Third");

  // 👍A) First Second undefined Third      💡B) First Third Second
  // 💖C) First Second Third undefined      😀D) First Second Third

  /*
  Answer is D) First Second Third because as there is no resolve in Promise constructor, So it will not go inside of .then block.
  */
}
// MCQ20();

// 👉 MCQ-21
function MCQ21() {
  const fetchData = function () {
    return new Promise((resolve, reject) => {
      reject();
    });
  };

  fetchData()
    .then(() => {
      console.log("Success 1");
    })
    .catch(() => {
      console.log("Error 1");
    })
    .then(() => {
      console.log("Success 2");
    });

  // 👍A) Error 1 TypeError    💡B) Error 1
  // 💖C) Error 1 Success 2    😀D) undefined

  /*
  Answer is C) Error 1 Success 2 because in promise chaining .then method below .catch method will be called if in .catch method we are not 
  returning rejected promise ( by default implicitly returns a promise that is handled by it's below .then method )
  */
}
// MCQ21();

// 👉 MCQ-22
function MCQ22() {
  function foo() {
    let a = (b = 0);
    a++;
    return a;
  }
  foo();
  console.log(typeof a);
  console.log(typeof b);

  // 👍A) undefined number        💡B) ReferenceError number
  // 💖C) undefined undefined     😀D) number number

  /* 
  Answer is A) undefined number because variable a is declared with let it is blocked scope and will be "not defined" outside function foo().
  The typeof operator returns "undefined" even for “undeclared” (or “not defined”) variables.
  Notice that there was no error thrown when we executed typeof a, even though a is an undeclared variable. 
  This is a special safety guard in the behavior of typeof. 
  and variable b is a just global scope variable hence it will be available outside function foo() also. 
  */
}
// MCQ22();

// 👉 MCQ-23
function MCQ23() {
  console.log("start");

  setTimeout(() => {
    console.log("first");
  }, 0);

  Promise.resolve("second").then((res) => console.log(res));

  console.log("end");

  // 👍A) start end first second       💡B) start first second end
  // 💖C) start end second first       😀D) start first end second

  /* 
  Answer is C) start end second first because callback function attached to Promises added into microtask queue 
  whereas callback function of setTimeout added into callback ( macroTask ) queue. 
  microTask queue has more priority than callback ( macroTask ) queue.
  */
}
// MCQ23();

// 👉 MCQ-24
function MCQ24() {
  const person1 = {
    name: "Jayesh",
    age: 24,
  };

  const person2 = person1;
  person2.name = "Virat";

  console.log(person1.name);
  console.log(person2.name);

  // 👍A) Jayesh Virat  💡B) Virat Virat
  // 💖C) Virat Jayesh  😀D) Jayesh Jayesh

  /* 
  Answer is B) Virat Virat because objects are passed as a reference, person1 and person2 will hold the same memory address
  and altering any property of person2 will modify property of person1 as well.
  */
}
// MCQ24();

// Basic form defined with real time password and name validation //

import React, { useEffect, useState } from "react";

const SignUp = () => {
  const [name, setName] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [success, setsuccess] = useState(false);
  const [Err, setErr] = useState("");

  useEffect(() => {
    if (name && (name.length < 6 || name.length > 16)) {
      setErr("Name should be 6-16 characters long");
    } else {
      setErr("");
    }
  }, [name]);

  useEffect(() => {
    if (password && password.length < 9) {
      setErr("Passsword should be minimum 8 characters");
    } else if (password && confirmPassword && password !== confirmPassword) {
      setErr("Passwords do not match");
    } else {
      setErr("");
    }
  }, [password, confirmPassword]);

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log("here");
    console.log(Err);
    console.log({ name, password });
    if (Err === "") {
      console.log("inside");
      setsuccess(true);
    }
  };

  return (
    <div>
      {success ? (
        <div>Success!! You can now Login....</div>
      ) : (
        <form
          onSubmit={handleSubmit}
          style={{ display: "flex", flexDirection: "column", width: "300px" }}
        >
          <label htmlFor="name">Name</label>
          <input
            type="text"
            id={name}
            name="name"
            value={name}
            required
            onChange={(e) => {
              setName(e.target.value);
            }}
          />
          <label htmlFor="password">Password</label>
          <input
            type="password"
            id={password}
            name="password"
            value={password}
            required
            onChange={(e) => {
              setPassword(e.target.value);
            }}
          />
          <label htmlFor="confirmPassword">Confirm Password</label>
          <input
            type="password"
            id={password}
            name="confirmPassword"
            value={confirmPassword}
            required
            onChange={(e) => {
              setConfirmPassword(e.target.value);
            }}
          />
          <div
            style={{
              display: "flex",
              justifyContent: "center",
              marginTop: "10px"
            }}
          >
            <button>Submit</button>
          </div>
          <p>{Err}</p>
        </form>
      )}
    </div>
  );
};

export default SignUp;
--------------------------------------------------------------------------------------------------------------------------

//Api calling....

import "./styles.css";
import React, { useEffect, useState } from "react";
import axios from "axios";

function UserTable({ users }) {
  return (
    <table>
      <thead>
        <tr>
          <th>id</th>
          <th>Name</th>
          <th>email</th>
        </tr>
      </thead>
      <tbody>
        {users.map((user) => (
          <tr key={user.id}>
            <td>{user.id}</td>
            <td>{user.name}</td>
            <td>{user.email}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}

export default function App() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true); // Initialize as true
  const [search, setSearch] = useState("");
  const [err, setErr] = useState("");

  let API = "https://jsonplaceholder.typicode.com/user";

  async function fetchUsers() {
    try {
      let { data } = await axios.get(API);
      setErr(false);
      setLoading(false); // Set loading to false when data is fetched
      if (data.length > 0) {
        if (search) {
          const filteredData = data.filter((d) =>
            d.name.toLowerCase().includes(search.toLowerCase())
          );
          setUsers(filteredData);
        } else {
          setUsers(data);
        }
      }
    } catch (err) {
      console.log(err);
      setErr(true);
      setLoading(false);
    }
  }

  useEffect(() => {
    setLoading(true);
    fetchUsers();
  }, [search]);

  const Debounce = (cb, delay = 1000) => {
    let timer;
    return (...args) => {
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => cb(...args), delay);
    };
  };

  const handleChange = (e) => {
    setSearch(e.target.value);
  };

  return (
    <div>
      {loading ? (
        "Loading.............."
      ) : err ? (
        "Error"
      ) : (
        <div>
          <input
            type="text"
            name="search"
            id="search"
            value={search}
            onChange={handleChange}
          />
          <UserTable users={users} />
        </div>
      )}
    </div>
  );
}


